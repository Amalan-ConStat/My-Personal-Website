---
title: 'optim: Estimating the shape parameters of Beta-Binomial Distribution'
author: M.Amalan
date: '2018-12-14'
slug: optim-estimating-the-shape-parameters-of-beta-binomial-distribution
categories:
  - fitODBOD
tags:
  - optim
  - fitODBOD
  - R
image:
  caption: ''
  focal_point: ''
---

<script src="/rmarkdown-libs/kePrint/kePrint.js"></script>


<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>When we need to estimate parameters from a discrete distribution or continuous distribution or a function we can use the below mentioned R function. We will be using the technique of maximizing the Log Likelihood function or minimizing the Negative Log Likelihood function. Based on this technique we will compare the mathematical methods of the R function <a href="https://www.rdocumentation.org/packages/stats/versions/3.5.1/topics/optim">optim</a>, because it might benefit people who are struggling which method to choose. We have 6 methods in total accoding to documentation.</p>
<p>Using the <a href="https://cran.r-project.org/package=fitODBOD">fitODBOD</a> package, I will use the Alcohol Consumption data to try and model it for the Beta Binomial Distribution, which has two shape parameters to estimate. The process is that we find values for shape parameters a and b (or <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span>) which will maximize the Log Likelihood function of Beta Binomial Distribution or in our case minimize the Negative Log Likelihood function of Beta Binomial Distribution.</p>
<p>Above mentioned Beta-Binomial distributions Probability Mass function is denoted as</p>
<p><span class="math display">\[P_{BetaBin}(x)= {n \choose x} \frac{B(\alpha+x,n+\beta-x)}{B(\alpha,\beta)} \]</span></p>
<p>where <span class="math inline">\(n=0,1,2,...\)</span>, <span class="math inline">\(x=0,1,2,...,n\)</span> and <span class="math inline">\(\alpha,\beta &gt; 0\)</span>. Further <span class="math inline">\(x\)</span> is the Binomial Random variable, a,b(or <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>) are shape parameters and <span class="math inline">\(n\)</span> is the binomial trial value. Also B(<span class="math inline">\(\alpha\)</span>,<span class="math inline">\(\beta\)</span>) is the beta function. In this distribution we have to estimate the values for a and b.</p>
<p>Further, using the PMF we can construct the Likelihood function for <span class="math inline">\(\Omega_{BB}=(\alpha,\beta)^T\)</span> as given below:</p>
<p><span class="math display">\[L(\Omega_{BB}|x)=\prod_{i=1}^{N} \binom{n}{x_i} \frac{B(\alpha+x_i,n+\beta-x_i)}{B(\alpha,\beta)}\]</span></p>
<p>where N is the Number of observations. Then Negative Log Likelihood function is given as</p>
<p><span class="math display">\[l(\Omega_{BB}|x)=-\sum_{i=1}^{N} log\binom{n}{x_i} + \sum_{i=1}^{N} log(B(\alpha+x_i,n+\beta-x_i)) - Nlog(B(\alpha,\beta))\]</span></p>
<p>In the package fitODBOD we have the function EstMLEBetaBin which is constructed based on the above Negative Log Likelihood function and we will use it.</p>
<p>We take Log to transform the Likelihood function values into small values, which will simplify the computation process and save time. The optim function uses specific mathematical methods to find the most appropriate shape parameter values.</p>
<p>They are given below in point form 1. Nelder Mead 2. BFGS 3. CG 4. L-BFGS-B 5. SANN 6. Brent</p>
<p>Alcohol Consumption data has two sets of frequency values but only values from week 1 will be used. Below is the the Alcohol Consumption data, where number of observations is 399 and the Binomial Random variable is a vector of values from zero to seven.</p>
<pre class="r"><code>library(fitODBOD)
kable(Alcohol_data,&quot;html&quot;,align=c(&#39;c&#39;,&#39;c&#39;,&#39;c&#39;)) %&gt;%
  kable_styling(bootstrap_options = c(&quot;striped&quot;),font_size = 14,full_width = F) %&gt;%
  row_spec(0,color = &quot;blue&quot;) %&gt;%
  column_spec(1,color = &quot;red&quot;)</code></pre>
<table class="table table-striped" style="font-size: 14px; width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:center;color: blue;">
Days
</th>
<th style="text-align:center;color: blue;">
week1
</th>
<th style="text-align:center;color: blue;">
week2
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;color: red;">
0
</td>
<td style="text-align:center;">
47
</td>
<td style="text-align:center;">
42
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
1
</td>
<td style="text-align:center;">
54
</td>
<td style="text-align:center;">
47
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
2
</td>
<td style="text-align:center;">
43
</td>
<td style="text-align:center;">
54
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
3
</td>
<td style="text-align:center;">
40
</td>
<td style="text-align:center;">
40
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
4
</td>
<td style="text-align:center;">
40
</td>
<td style="text-align:center;">
49
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
5
</td>
<td style="text-align:center;">
41
</td>
<td style="text-align:center;">
40
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
6
</td>
<td style="text-align:center;">
39
</td>
<td style="text-align:center;">
43
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
7
</td>
<td style="text-align:center;">
95
</td>
<td style="text-align:center;">
84
</td>
</tr>
</tbody>
</table>
<div id="optim-function" class="section level2">
<h2>optim Function</h2>
<p><a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/00Index.html#O">optim</a> is the function in concern. <a href="https://www.rdocumentation.org/packages/stats/versions/3.5.1/topics/optim">Documentation</a> of the optim function is useful and it indicates that this function is only used on one input situations. This means our EstMLEBetaBin function has to be modified. Reason for this is that only the parameters that should be estimated need to be input values but our EstMLEBetaBin function has four parameters which are a,b,x(Binomial Random Variable) and freq(corresponding frequency values).</p>
<p>While using optim function first index refers to <span class="math inline">\(\alpha\)</span> or a and second index refers to <span class="math inline">\(\beta\)</span> or b. Further, we have to input the observations or in our case the Binomial random variable values and their respective frequencies. I think it is inconvenient to modify the EstMLEBetaBin function, because if we want to estimate parameters for different data-sets it would become extra work. After modification we have a new function which is foroptim and I can use it for demonstration and comparison.</p>
<p>Below is the code to estimation and going through the outputs. It should be noted that we have to provide initial parameter values as an input to the optim function and it is best to provide values in the domain of<br />
values a and b.</p>
<p>Here the shape parameters a and b are in the region of greater than zero but less than positive infinity. So for the initial parameters of a=0.1 and b=0.2 we will be finding parameters from different methods which would minimize the Negative Log Likelihood function of Beta-Binomial distribution.</p>
<pre class="r"><code># new function to facilitate optim criteria
# only one input but has two elements
foroptim&lt;-function(a)
  {
  EstMLEBetaBin(x=Alcohol_data$Days, freq=Alcohol_data$week1,a=a[1],b=a[2])
  }</code></pre>
<p>So the foroptim function can be used as above and parameters are estimated for <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> (or a, b) for the Alcohol Consumption data week 1. Further we have scrutinized the outputs.</p>
<ul>
<li>package : stats</li>
<li>No of Inputs: 7</li>
<li>Minimum required Inputs : 2</li>
<li>Class of output : list</li>
<li>No of outputs: 5</li>
<li>No of Analytical Methods : 6</li>
<li>Default Method : Nelder-Mead</li>
</ul>
</div>
</div>
<div id="using-nelder-and-mead-method" class="section level1">
<h1>Using Nelder and Mead method</h1>
<p>If we do not mention any method it will automatically consider Nelder and Mead method. According to the documentation says that it uses only function values and is robust but relatively slow. It will work reasonably well for non-differentiable functions.</p>
<p>Nelder, J.A. and Mead, R., 1965. A simplex method for function minimization. The computer journal, 7(4), pp.308-313.</p>
<pre class="r"><code># optimizing values for a,b using default inputs
NM_answer&lt;-optim(par=c(0.1,0.2),fn=foroptim)

# the outputs
NM_answer$par # estimated values for a, b
NM_answer$value # minimized function value 
NM_answer$counts  # see the documentation to understand
NM_answer$convergence # indicates successful completion
NM_answer$message # additional information

# fitting the Beta-Binomial distribution with estimated shape parameter  values
fitBetaBin(Alcohol_data$Days,Alcohol_data$week1,NM_answer$par[1],NM_answer$par[2])</code></pre>
</div>
<div id="using-bfgs-method" class="section level1">
<h1>Using BFGS method</h1>
<p>The documentation indicates that BFGS is a Quasi-Newton method (also known as a variable metric algorithm), specifically that published simultaneously in 1970 by Broyden, Fletcher, Goldfarb and Shanno. This uses function values and gradients to build up a picture of the surface to be optimized.</p>
<p>Broyden, C.G., 1967. Quasi-Newton methods and their application to function minimisation. Mathematics of Computation, 21(99), pp.368-381.</p>
<pre class="r"><code># optimizing values for a,b using BFGS inputs
BFGS_answer&lt;-optim(par=c(0.1,0.2),fn=foroptim,method = &quot;BFGS&quot;)

# the outputs
BFGS_answer$par # estimated values for a, b
BFGS_answer$value # minimized function value 
BFGS_answer$counts  # see the documentation to understand
BFGS_answer$convergence # indicates successful completion
BFGS_answer$message # additional information

# fitting the Beta-Binomial distribution with estimated shape parameter  values
fitBetaBin(Alcohol_data$Days,Alcohol_data$week1,BFGS_answer$par[1],BFGS_answer$par[2])</code></pre>
</div>
<div id="using-cg-method" class="section level1">
<h1>Using CG method</h1>
<p>According to the documentation Method “CG” is a conjugate gradients method based on that by Fletcher and Reeves (1964) (but with the option of Polak–Ribiere or Beale–Sorenson updates). Conjugate gradient methods will generally be more fragile than the BFGS method, but as they do not store a matrix they may be successful in much larger optimization problems.</p>
<p>Fletcher, R. and Reeves, C.M., 1964. Function minimization by conjugate gradients. The computer journal, 7(2), pp.149-154.</p>
<pre class="r"><code># optimizing values for a,b using CG inputs
CG_answer&lt;-optim(par=c(0.1,0.2),fn=foroptim,method = &quot;CG&quot;)

# the outputs
CG_answer$par # estimated values for a, b
CG_answer$value # minimized function value 
CG_answer$counts  # see the documentation to understand
CG_answer$convergence # indicates successful completion
CG_answer$message # additional information

# fitting the Beta-Binomial distribution with estimated shape parameter  values
fitBetaBin(Alcohol_data$Days,Alcohol_data$week1,CG_answer$par[1],CG_answer$par[2])</code></pre>
</div>
<div id="using-l-bfgs-b-method" class="section level1">
<h1>Using L-BFGS-B method</h1>
<p>Method “L-BFGS-B” is that of Byrd et. al. (1995) which allows box constraints, that is each variable can be given a lower and/or upper bound. The initial value must satisfy the constraints. This uses a limited-memory modification of the BFGS quasi-Newton method. If non-trivial bounds are supplied, this method will be selected, with a warning.</p>
<p>Byrd, R.H., Lu, P., Nocedal, J. and Zhu, C., 1995. A limited memory algorithm for bound constrained optimization. SIAM Journal on Scientific Computing, 16(5), pp.1190-1208.</p>
<pre class="r"><code># optimizing values for a,b using L-BFGS-B inputs
L_BFGS_B_answer&lt;-optim(par=c(0.1,0.2),fn=foroptim,method = &quot;L-BFGS-B&quot;)

# the outputs
L_BFGS_B_answer$par # estimated values for a, b
L_BFGS_B_answer$value # minimized function value 
L_BFGS_B_answer$counts  # see the documentation to understand
L_BFGS_B_answer$convergence # indicates successful completion
L_BFGS_B_answer$message # additional information

# fitting the Beta-Binomial distribution with estimated shape parameter  values
fitBetaBin(Alcohol_data$Days,Alcohol_data$week1,L_BFGS_B_answer$par[1],L_BFGS_B_answer$par[2])</code></pre>
</div>
<div id="using-sann-method" class="section level1">
<h1>Using SANN method</h1>
<p>Method “SANN” is by default a variant of simulated annealing given in Belisle (1992). Simulated-annealing belongs to the class of stochastic global optimization methods. It uses only function values but is relatively slow. It will also work for non-differentiable functions. This implementation uses the Metropolis function for the acceptance probability. By default the next candidate point is generated from a Gaussian Markov kernel with scale proportional to the actual temperature. If a function to generate a new candidate point is given, method “SANN” can also be used to solve combinatorial optimization problems. Temperatures are decreased according to the logarithmic cooling schedule as given in Belisle (1992, p.890); specifically, the temperature is set to <span class="math inline">\(temp / log(((t-1) %/% tmax)*tmax + exp(1))\)</span>, where <span class="math inline">\(t\)</span> is the current iteration step and temp and tmax are specifiable via control, see below. Note that the “SANN” method depends critically on the settings of the control parameters. It is not a general-purpose method but can be very useful in getting to a good value on a very rough surface.</p>
<p>Belisle, C.J., 1992. Convergence theorems for a class of simulated annealing algorithms on R d. Journal of Applied Probability, 29(4), pp.885-895.</p>
<pre class="r"><code># optimizing values for a,b using default inputs
SANN_answer&lt;-optim(par=c(0.1,0.2),fn=foroptim,method = &quot;SANN&quot;)

# the outputs
SANN_answer$par # estimated values for a, b
SANN_answer$value # minimized function value 
SANN_answer$counts  # see the documentation to understand
SANN_answer$convergence # indicates successful completion
SANN_answer$message # additional information

# fitting the Beta-Binomial distribution with estimated shape parameter  values
fitBetaBin(Alcohol_data$Days,Alcohol_data$week1,SANN_answer$par[1],SANN_answer$par[2])</code></pre>
</div>
<div id="using-brent-method" class="section level1">
<h1>Using Brent method</h1>
<p>Method “Brent” is for one-dimensional problems only, using optimize(). It can be useful in cases where optim() is used inside other functions where only method can be specified, such as in mle from package stats4. Brent method does not work for our situation.</p>
<p>Brent, R.P., 2013. Algorithms for minimization without derivatives. Courier Corporation.</p>
</div>
<div id="summary-of-time-evaluation-for-the-r-functions" class="section level1">
<h1>Summary of Time evaluation for the R functions</h1>
<p>Further at the beginning I have considered to evaluate the time of system process for the methods to produce results and compare them. In order to do this time comparison it is possible to use the <a href="https://www.rdocumentation.org/packages/rbenchmark/versions/1.0.0/topics/benchmark">benchmark</a> function of <a href="https://cran.r-project.org/package=rbenchmark">rbenchmark</a> package and below mentioned code chunk provides the output in a table form which includes the functions and their respective time values. The estimation process of the parameters where each method has been replicated 1000 times to receive a more accurate and strong table of time values.</p>
<p>The table is in accordance to the elapsed time value column in ascending order. According to this we can see that least time takes to the Nelder Mead method and most time is taken to the SANN method. These times completely depends on the Negative Log Likelihood function you need to minimize, the data you provided, the number of estimators that needs to be estimated and finally the complexity of the function.</p>
<pre class="r"><code>library(rbenchmark)

Results1&lt;-benchmark(
          &quot;Nelder\nMead&quot;={ optim(par = c(0.1,0.2), fn = foroptim)},
          &quot;BFGS&quot;={optim(par = c(0.1,0.2), fn = foroptim,method = &quot;BFGS&quot;)},
          &quot;CG&quot;={optim(par = c(0.1,0.2), fn = foroptim,method = &quot;CG&quot;)},
          &quot;L-BFGS-B&quot;={optim(par = c(0.1,0.2), fn = foroptim,method = &quot;L-BFGS-B&quot;)},
          &quot;SANN&quot;={optim(par = c(0.1,0.2), fn = foroptim,method = &quot;SANN&quot;)},
          replications = 1000,
          columns = c(&quot;test&quot;,&quot;replications&quot;,&quot;elapsed&quot;,
                      &quot;relative&quot;,&quot;user.self&quot;,&quot;sys.self&quot;),
          order = &#39;elapsed&#39;
          )

kable(Results1,&quot;html&quot;,align = c(&#39;c&#39;,&#39;c&#39;,&#39;c&#39;,&#39;c&#39;,&#39;c&#39;,&#39;c&#39;)) %&gt;%
  kable_styling(full_width = T,bootstrap_options = c(&quot;striped&quot;),font_size = 14) %&gt;%
  row_spec(0,color = &quot;blue&quot;) %&gt;%
  column_spec(1,color = &quot;red&quot;)</code></pre>
<table class="table table-striped" style="font-size: 14px; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;color: blue;">
</th>
<th style="text-align:center;color: blue;">
test
</th>
<th style="text-align:center;color: blue;">
replications
</th>
<th style="text-align:center;color: blue;">
elapsed
</th>
<th style="text-align:center;color: blue;">
relative
</th>
<th style="text-align:center;color: blue;">
user.self
</th>
<th style="text-align:center;color: blue;">
sys.self
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;color: red;">
1
</td>
<td style="text-align:center;">
Nelder Mead
</td>
<td style="text-align:center;">
1000
</td>
<td style="text-align:center;">
12.14
</td>
<td style="text-align:center;">
1.000
</td>
<td style="text-align:center;">
11.80
</td>
<td style="text-align:center;">
0.04
</td>
</tr>
<tr>
<td style="text-align:left;color: red;">
4
</td>
<td style="text-align:center;">
L-BFGS-B
</td>
<td style="text-align:center;">
1000
</td>
<td style="text-align:center;">
13.65
</td>
<td style="text-align:center;">
1.124
</td>
<td style="text-align:center;">
12.99
</td>
<td style="text-align:center;">
0.03
</td>
</tr>
<tr>
<td style="text-align:left;color: red;">
2
</td>
<td style="text-align:center;">
BFGS
</td>
<td style="text-align:center;">
1000
</td>
<td style="text-align:center;">
20.25
</td>
<td style="text-align:center;">
1.668
</td>
<td style="text-align:center;">
20.09
</td>
<td style="text-align:center;">
0.00
</td>
</tr>
<tr>
<td style="text-align:left;color: red;">
3
</td>
<td style="text-align:center;">
CG
</td>
<td style="text-align:center;">
1000
</td>
<td style="text-align:center;">
40.94
</td>
<td style="text-align:center;">
3.372
</td>
<td style="text-align:center;">
40.28
</td>
<td style="text-align:center;">
0.05
</td>
</tr>
<tr>
<td style="text-align:left;color: red;">
5
</td>
<td style="text-align:center;">
SANN
</td>
<td style="text-align:center;">
1000
</td>
<td style="text-align:center;">
2447.72
</td>
<td style="text-align:center;">
201.624
</td>
<td style="text-align:center;">
2197.94
</td>
<td style="text-align:center;">
5.69
</td>
</tr>
</tbody>
</table>
</div>
<div id="summary-of-results-after-estimating-parameters-using-the-r-functions" class="section level1">
<h1>Summary of Results after estimating parameters using the R functions</h1>
<p>After using the methods Nelder Mead, BFGS, CG, L-BFGS-B and SANN to estimate the shape parameters a, b we can use the estimated parameters in the function fitBetaBin. Using this function we can find expected frequencies for each of these functions and compare p-values and over-dispersion and understand if using different estimation methods had any effect on them.</p>
<p>According to the below table there is no significant changes between the expected frequencies except while using SANN method. All five methods generate different Over dispersion values in the first three decimal places. First three decimal places are similar for all 5 estimation methods, but after this they are different. Negative Log Likelihood values and p values are same for all 5 methods. This is a clear indication of it does not matter what method we use the estimation will occur effectively but only efficiency will be affected.</p>
<table class="table table-striped" style="font-size: 14px; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:center;color: blue;">
BinomialRandomVariable
</th>
<th style="text-align:center;color: blue;">
Frequency
</th>
<th style="text-align:center;color: blue;">
NelderMead
</th>
<th style="text-align:center;color: blue;">
BFGS
</th>
<th style="text-align:center;color: blue;">
CG
</th>
<th style="text-align:center;color: blue;">
LBFGSB
</th>
<th style="text-align:center;color: blue;">
SANN
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;color: red;">
0
</td>
<td style="text-align:center;">
47
</td>
<td style="text-align:center;">
54.61
</td>
<td style="text-align:center;">
54.62
</td>
<td style="text-align:center;">
54.62
</td>
<td style="text-align:center;">
54.62
</td>
<td style="text-align:center;">
54.75
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
1
</td>
<td style="text-align:center;">
54
</td>
<td style="text-align:center;">
42
</td>
<td style="text-align:center;">
42
</td>
<td style="text-align:center;">
42
</td>
<td style="text-align:center;">
42
</td>
<td style="text-align:center;">
42.02
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
2
</td>
<td style="text-align:center;">
43
</td>
<td style="text-align:center;">
38.91
</td>
<td style="text-align:center;">
38.9
</td>
<td style="text-align:center;">
38.9
</td>
<td style="text-align:center;">
38.9
</td>
<td style="text-align:center;">
38.89
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
3
</td>
<td style="text-align:center;">
40
</td>
<td style="text-align:center;">
38.54
</td>
<td style="text-align:center;">
38.54
</td>
<td style="text-align:center;">
38.54
</td>
<td style="text-align:center;">
38.54
</td>
<td style="text-align:center;">
38.52
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
4
</td>
<td style="text-align:center;">
40
</td>
<td style="text-align:center;">
40.07
</td>
<td style="text-align:center;">
40.07
</td>
<td style="text-align:center;">
40.07
</td>
<td style="text-align:center;">
40.07
</td>
<td style="text-align:center;">
40.04
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
5
</td>
<td style="text-align:center;">
41
</td>
<td style="text-align:center;">
44
</td>
<td style="text-align:center;">
43.99
</td>
<td style="text-align:center;">
44
</td>
<td style="text-align:center;">
44
</td>
<td style="text-align:center;">
43.96
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
6
</td>
<td style="text-align:center;">
39
</td>
<td style="text-align:center;">
53.09
</td>
<td style="text-align:center;">
53.09
</td>
<td style="text-align:center;">
53.09
</td>
<td style="text-align:center;">
53.09
</td>
<td style="text-align:center;">
53.05
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
7
</td>
<td style="text-align:center;">
95
</td>
<td style="text-align:center;">
87.77
</td>
<td style="text-align:center;">
87.8
</td>
<td style="text-align:center;">
87.78
</td>
<td style="text-align:center;">
87.78
</td>
<td style="text-align:center;">
87.78
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
Total No of Observations
</td>
<td style="text-align:center;">
399
</td>
<td style="text-align:center;">
398.99
</td>
<td style="text-align:center;">
399.01
</td>
<td style="text-align:center;">
399
</td>
<td style="text-align:center;">
399
</td>
<td style="text-align:center;">
399
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
p-value
</td>
<td style="text-align:center;">
</td>
<td style="text-align:center;">
0.0902
</td>
<td style="text-align:center;">
0.0903
</td>
<td style="text-align:center;">
0.0901
</td>
<td style="text-align:center;">
0.0901
</td>
<td style="text-align:center;">
0.0901
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
Estimated a and b
</td>
<td style="text-align:center;">
</td>
<td style="text-align:center;">
a=0.7230707 b=0.5809894
</td>
<td style="text-align:center;">
a=0.7228930 b=0.5807279
</td>
<td style="text-align:center;">
a=0.7229414 b=0.5808477
</td>
<td style="text-align:center;">
a=0.7229432 b=0.5808496
</td>
<td style="text-align:center;">
a=0.7215669 b=0.5802982
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
Negative Log Likelihood
</td>
<td style="text-align:center;">
</td>
<td style="text-align:center;">
813.4571
</td>
<td style="text-align:center;">
813.4571
</td>
<td style="text-align:center;">
813.4571
</td>
<td style="text-align:center;">
813.4571
</td>
<td style="text-align:center;">
813.4573
</td>
</tr>
<tr>
<td style="text-align:center;color: red;">
Over Dispersion
</td>
<td style="text-align:center;">
</td>
<td style="text-align:center;">
0.4340165
</td>
<td style="text-align:center;">
0.4340992
</td>
<td style="text-align:center;">
0.4340675
</td>
<td style="text-align:center;">
0.4340668
</td>
<td style="text-align:center;">
0.4344303
</td>
</tr>
</tbody>
</table>
</div>
<div id="final-conclusion" class="section level1">
<h1>Final conclusion</h1>
<p>We had 6 methods to compare but choosing one over the other is completely harmless to the final result of estimation as seen by our tables. And our situation foces us to not use the Brent method. The only issue is time, therefore I would recommend chose the best method based on your needs of output and research objective.</p>
<p><em>Thank You</em></p>
</div>
